---
title: Using Structured Outputs (JSON mode) with Text Gen endpoints
subtitle: Ensure Text Gen outputs fit into your desired JSON schema.
slug: text-gen-solution/json-mode
---

OctoAI's Large Language Models (LLMs) can generate outputs that not only adhere to JSON format but also align with your unique schema specifications. This guide covers two approaches to JSON mode: OpenAI Compatible JSON mode for Llama-3.1-8B and 70B, and Legacy JSON mode.

**Supported models
* Llama 3.1 8B 
* Llama 3.1 70B
* Hermes 2 Pro Llama 3 8B (Legacy mode)
* Mistral 7B (Legacy mode)
* Nous Hermes Mixtral 8x7B  (Legacy mode)
* Mixtral 8x7B (Legacy mode)
* WizardLM 8x22B (Legacy mode)

## OpenAI Compatible JSON mode for Llama-3.1-8B and 70B

This section covers the new JSON mode compatible with OpenAI's new response format standard, specifically for Llama-3.1-8B and 70B models.

### Setup

First, set up the OpenAI client and set it to run with OctoAI base and tokens.

```python
from openai import OpenAI
import os

client = OpenAI(
    base_url="https://text.octoai.run/v1",
    api_key=os.environ["OCTOAI_API_KEY"],
)

model = "meta-llama-3.1-8b-instruct"
```

### Generate JSON without adhering to any schema (json_object)

If you want the response as a JSON object but without any specific schema:

```python
import json

def generate_json_object():
    response = client.chat.completions.create(
        model=model,
        messages=[
            {
                "role": "system",
                "content": "Generate a JSON object, without any additional text or comments.",
            },
            {"role": "user", "content": "who won the world cup in 2022? answer in JSON"},
        ],
        max_tokens=max_tokens,
        response_format={
            "type": "json_object",
        },
        temperature=0,
    )

    content = response.choices[0].message.content
    data = json.loads(content)
    return data
```

### Generating JSON adhering to schema (without constrained decoding):

For generating JSON that adheres to a simple schema, but without strict (guarenteed) schema following (see the "strict": False below). 
This mode is faster and works on both Llama-3.1-8B-Instruct and Llama-3.1-70B-Instruct. For most use cases, it is sufficient and recommended.

```python
from pydantic import BaseModel
from jsonschema import validate

class Output(BaseModel):
    answer: str

def generate_json_schema_strict_false():
    schema = Output.model_json_schema()
    response = client.chat.completions.create(
        model=model,
        messages=[
            {
                "role": "system",
                "content": "Generate a JSON object, without any additional text or comments.",
            },
            {"role": "user", "content": "who won the world cup in 2022?"},
        ],
        response_format={
            "type": "json_schema",
            "json_schema": {"name": "output", "schema": schema, "strict": False},
        },
        temperature=0,
    )
    content = response.choices[0].message.content
    data = json.loads(content)
    validate(instance=data, schema=schema)
    return data
```

### Generating JSON adhering to schema (with constrained decoding):

When you need strict adherence to a JSON schema, you can activate this mode on Llama-3.1-8b-Instruct *only*. This is recommended for more complex schemas. Activating this mode can create a latency increase.

```python
from textwrap import dedent

math_tutor_prompt = """
    You are a helpful math tutor. You will be provided with a math problem,
    and your goal will be to output a step by step solution, along with a final answer.
    For each step, just provide the output as an equation use the explanation field to detail the reasoning.
"""

question = "how can I solve 8x + 7 = -23"

schema = {
    "type": "object",
    "properties": {
        "steps": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "explanation": {"type": "string"},
                    "output": {"type": "string"},
                },
                "required": ["explanation", "output"],
                "additionalProperties": False,
            },
        },
        "final_answer": {"type": "string"},
    },
    "required": ["steps", "final_answer"],
    "additionalProperties": False,
}

def generate_json_schema_strict_true():
    response = client.chat.completions.create(
        model=model,
        messages=[
            {"role": "system", "content": dedent(math_tutor_prompt)},
            {"role": "user", "content": question},
        ],
        response_format={
            "type": "json_schema",
            "json_schema": {"name": "math_reasoning", "schema": schema, "strict": True},
        },
        temperature=0,
    )
    content = response.choices[0].message.content
    data = json.loads(content)
    validate(instance=data, schema=schema)
    return data
```

## Legacy JSON mode

This section covers the "legacy" JSON mode, which is still supported for the following models:
* Hermes 2 Pro Llama 3 8B
* Mistral 7B
* Nous Hermes Mixtral 8x7B
* Mixtral 8x7B
* WizardLM 8x22B

### Getting started

Setup credentials:

```bash
export OCTOAI_TOKEN=YOUR_TOKEN_HERE
```

Curl example (Mistral-7B): Let's say that you want to ensure that your LLM responses format user feedback about cars into a usable JSON format. To do so, you provide the LLM with a response schema ensuring that it knows it must provide "color" and "maker" in a structured format--see "response format below":

```bash
curl -X POST "https://text.octoai.run/v1/chat/completions" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $OCTOAI_TOKEN" \
  --data-raw '{
        "messages": [
            {
                "role": "system",
                "content": "You are a helpful assistant."
            },
            {
                "role": "user",
                "content": "the car was black and it was a toyota camry."
            }
        ],
        "model": "mistral-7b-instruct",
        "max_tokens": 512,
        "presence_penalty": 0,
        "temperature": 0.1,
        "top_p": 0.9,
        "response_format": {
            "type": "json_object",
            "schema": {"properties": {"color": {"title": "Color", "type": "string"}, "maker": {"title": "Maker", "type": "string"}}, "required": ["color", "maker"], "title": "Car", "type": "object"}
        }
    }'
```

The LLM will respond in the exact schema specified:

```bash
{
  "id": "chatcmpl-d5d81b7c80b249ea8177f95f68a51d8e",
  "object": "chat.completion",
  "created": 1709830931,
  "model": "mistral-7b-instruct",
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant",
        "content": "{\"color\": \"black\", \"maker\": \"Toyota\"}",
        "function_call": null
      },
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "prompt_tokens": 98,
    "completion_tokens": 16,
    "total_tokens": 114
  }
}
```

### Pydantic and OctoAI's Python SDK

Pydantic is a popular Python library for data validation and settings management using Python type annotations. By combining Pydantic with the OctoAI SDK, you can easily define the desired JSON schema for your LLM responses and ensure that the generated content adheres to that structure.

First, make sure you have the required packages installed:

```bash
python3 -m pip install openai pydantic==2.5.3
```

#### Basic example

Let's start with a basic example to demonstrate how Pydantic and the OctoAI SDK work together. In this example, we'll define a simple Car model with color and maker attributes, and ask the LLM to generate a response that fits this schema.

```python
from octoai.client import OctoAI
from octoai.text_gen import ChatCompletionResponseFormat, ChatMessage
from pydantic import BaseModel, Field
from typing import List

client = OctoAI()

class Car(BaseModel):
    color: str
    maker: str

completion = client.text_gen.create_chat_completion(
    model="mistral-7b-instruct",
    messages=[
        ChatMessage(role="system", content="You are a helpful assistant."),
        ChatMessage(role="user", content="the car was black and it was a toyota camry."),
    ],
    max_tokens=512,
    presence_penalty=0,
    temperature=0.1,
    top_p=0.9,
    response_format=ChatCompletionResponseFormat(
        type="json_object",
        schema=Car.model_json_schema(),
    ),
)

print(completion.choices[0].message.content)
```

The key points to note here are:

1. We import the necessary classes from the OctoAI SDK: Client, TextModel, and ChatCompletionResponseFormat.
2. We define a Car class inheriting from BaseModel, specifying the color and maker attributes with their expected types.
3. When creating the chat completion, we set the response_format using ChatCompletionResponseFormat and include the JSON schema generated from our Car model using Car.model_json_schema().

The output will be a JSON object adhering to the specified schema:

```json
{ "color": "black", "maker": "Toyota" }
```

#### Array example

Next, let's look at an example involving arrays. Suppose we want the LLM to generate a list of names based on a given prompt. We can define a Meeting model with a names attribute of type List[str].

```python
from octoai.client import OctoAI
from octoai.text_gen import ChatCompletionResponseFormat, ChatMessage
from pydantic import BaseModel, Field
from typing import List

client = OctoAI()

class Meeting(BaseModel):
    names: List[str]


chat_completion = client.text_gen.create_chat_completion(
    model="<model>",
    messages=[
        ChatMessage(role="system", content="You are a helpful assistant."),
        ChatMessage(role="user", content="John and Jane meet the day after"),
    ],
    temperature=0,
    response_format=ChatCompletionResponseFormat(
        type="json_object",
        schema=Meeting.model_json_schema()
    ),
)

print(chat_completion.choices[0].message.content)
```

The LLM will generate a response containing an array of names:

```json
{ "names": ["John", "Jane"] }
```

#### Nested example

Finally, let's explore a more complex example involving nested models. In this case, we'll define a Person model with name and age attributes, and a Result model containing a sorted list of Person objects.

```python
class Person(BaseModel):
    """The object representing a person with name and age"""

    name: str = Field(description="Name of the person")
    age: int = Field(description="The age of the person")


class Result(BaseModel):
    """The format of the answer."""

    sorted_list: List[Person] = Field(description="List of the sorted objects")


completion = octoai.text_gen.create_chat_completion(
    model="mistral-7b-instruct",
    messages=[
        {
            "role": "system",
            "content": "You are a helpful assistant designed to output JSON.",
        },
        {
            "role": "user",
            "content": "Alice is 10 years old, Bob is 7 and carol is 2. Sort them by age in ascending order.",
        },
    ],
    max_tokens=512,
    presence_penalty=0,
    temperature=0.1,
    top_p=0.9,
    response_format=ChatCompletionResponseFormat(
        type="json_object",
        schema=Result.model_json_schema(),
    ),
)

print(completion.choices[0].message.content)
```

In this example:

1. We define a Person model with name and age attributes, along with descriptions using the Field function from Pydantic.
2. We define a Result model containing a sorted_list attribute of type List[Person].
3. When creating the chat completion, we set the response_format using ChatCompletionResponseFormat and include the JSON schema generated from our Result model.

The LLM will generate a response containing a sorted list of Person objects:

```json
{
  "sorted_list": [
    { "name": "Carol", "age": 2 },
    { "name": "Bob", "age": 7 },
    { "name": "Alice", "age": 10 }
  ]
}
```

### Instructor

Instructor makes it easy to reliably get structured data like JSON from Large Language Models (LLMs). Read more [here](https://jxnl.github.io/instructor/)

#### Install

```bash
python3 -m pip install instructor
```

#### Example

```python
import os
import openai
from pydantic import BaseModel
import instructor

client = openai.OpenAI(
    base_url="https://text.octoai.run/v1",
    api_key=os.environ["OCTOAI_TOKEN"],
)


# By default, the patch function will patch the ChatCompletion.create and ChatCompletion.create methods to support the response_model parameter
client = instructor.patch(client, mode=instructor.Mode.JSON_SCHEMA)


# Now, we can use the response_model parameter using only a base model
# rather than having to use the OpenAISchema class
class UserExtract(BaseModel):
    name: str
    age: int


user: UserExtract = client.chat.completions.create(
    model="mistral-7b-instruct",
    response_model=UserExtract,
    messages=[
        {"role": "user", "content": "Extract jason is 25 years old"},
    ],
)

print(user.model_dump_json(indent=2))
```

Let's break down the code step by step:

After importing the necessary modules and setting the clients, we:

1. We use the instructor.patch function to patch the ChatCompletion.create method of the OctoAI client. This allows us to use the response_model parameter directly with a Pydantic model.
2. We define a Pydantic model called UserExtract that represents the desired structure of the extracted user information. In this case, it has two fields: name (a string) and age (an integer).
3. We call the chat.completions.create method of the patched OctoAI client, specifying the model (mistral-7b-instruct), the response_model (our UserExtract model), and the user message that contains the information we want to extract.
4. Finally, we print the extracted user information using the model_dump_json method, which serializes the Pydantic model to a JSON string with indentation for better readability.

The output will be a JSON object containing the extracted user information, adhering to the specified UserExtract schema:

```json
{
  "name": "jason",
  "age": 25
}
```

By leveraging Instructor and the OctoAI SDK, you can easily define the desired output schema and ensure that the LLM generates structured data that fits your application's requirements. This simplifies the process of integrating LLM-generated content into your software systems.
